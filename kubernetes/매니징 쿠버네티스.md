# 매니징 쿠버네티스



## Ch1. 쿠버네티스란



* 쿠버네티스란?

  * 컨테이너화된 애플리케이션을 배포하기 위한 오픈소스 오케스트레이터

    

* 쿠버네티스의 장점
  * 오케스트레이션 API를 제공
    * 간단한 선언 구문을 사용하여 애플리케이션을 정의, 배포
  * 자가 재해 복구 알고리즘 제공
    * 오류 발생 시 애플리케이션을 복구
  * 쿠버네티스 API
    * 소프트웨어 무중단 업데이트가 용이하도록 도움
    * 서비스 로드 밸런서 제공
      * 서비스의 여러 레플리카 간에 트래픽을 쉽게 분산
    * 의존도를 낮춘 마이크로 서비스 아키텍쳐 제공
      * 서비스의 네이밍과 검색을 위한 툴을 제공



#### 1-1. 클러스터

> 클러스터란?
>
> * 정의
>   * 쿠버네티스가 최종 사용자에게 줄 수 있는 전체 컴퓨팅 리소스를 제공하기 위해 함께 작동하는 여러 시스템
> * 단일 API로 제어됨
> * 해당 API 사용자가 사용할 수 있는 시스템 모음



* 작동 방식

  * 시스템을 관리하기 위해서는 시스템의 작동 방식에 대한 완전한 이해가 필요하다. 

    * 구성 요소와 상호 동작 방식
    * 구성 요소의 결합 방식
    * 최종 사용자에게 제공되는 요소

    

* 클러스터 조정, 보안, 적용하기

  * 쿠버네티스 매니징을 위해 
    * 클러스터의 요소가 결합된 방법
    * 쿠버네티스 API 사용 방법 
    * 등을 숙지하여야 한다.
  * 클러스터와 클러스터의 사용량 주기에 대해 이해하고 쿠버네티스를 구성해야하 한다.
  * 클러스터는 애플리케이션의 배포 도구이자 보안상 취약점을 공격하기 위한 **매개체**가 될 수 있다.
    * 이와 관련하여 보안성을 강화할 수 있어야 한다.



* 문제에 대응하기

  * 적합한 메트릭( metric )을 올바르게 설정

    > metric이란?
    >
    > * 라우터가 목적지에 이르는 여러 경로 중 최적의 경로를 결정, 
    > * 서열 기준을 매길 수 있게끔 숫자로 환산하는 변수
    >   * 경로 상의 네트워크, 또는 링크들을 모두 거쳐 지나가는데 할당되는 비용을 계산
    >   * 가장 적은 메트릭 값을 갖는 경로가 최적의 경로
    > * 일반적으로 사용되는 메트릭 변수
    >   * Path Length  :  경로 거리 (Hop Count 등)
    >   * Reliability  :  신뢰성 유지 (링크 고장의 수, 전송 에러의 수 등)
    >   * Delay        :  걸리는 시간 (msec 등)
    >   * Bandwidth    :  사용가능한 용량 (전송선로 용량으로써의 MHz 등)
    >   * Load         :  가용자원에 대한 부하 (트래픽 등)
    >   *  Cost         :  링크 특성 또는 관리자의 정책적인 고려 등에 의해 값을 매김

    * 프로메테우스 오픈 소스 프로젝트와 같은 도구로 메트릭을 수집,
    * 그라파나와 같은 툴로 시각화 및 컨테이너 모니터링

  * 쿠버네티스의 모듈성과 멱등성

    * 문제 파악 후 솔루션 제공이 용이

  * 재해 복구 백업으로 문제 해결

    * 평소 절차에 대해 숙지하고 있어야 하며, 복구 시 다양한 유의사항에 맞추어 준비해두어야 한다.



* 새로운 기능과 사용자 정의 기능으로 시스템 확장하기
  * 쿠버네티스의 가장 큰 강점은 확장, 개선되는 라이브러리, 툴, 플랫폼의 성장에 있다.
  * 지속적 배포 툴( CD - continuous delivery )
    * 스피네이커( Spinnaker )
    * 젠킨스( Jenkins )
  * 헬름( Helm )
    * 전체 애플리케이션을 쉽게 패키징 및 배포
  * 데이스( Deis )
    * git push 스타일 개발자 워크 플로 제공
    * 쿠버네티스 위에서 Faas( functions as a service ) 기능 구현







## Ch2. 쿠버네티스 살펴보기



### 2-1. 컨테이너

* 컨테이너란?
  * 컨테이너 이미지
    * 애플리케이션 런타임을 포함
    * 바이너리, 라이브러리, 컨테이너를 실행하는데 필요한 데이터로 구성
    * 다양한 환경에서의 **이식성**을 제공 
  * 실행 중인 프로세스 또는 프로세스를 격리하는 일련의 운영체제 개념



* 이미지의 실행
  * 운영체제의 네임스페이스를 사용하여 실행



* 컨테이너 빌드 및 배포에 도움이 되는 툴
  1. 컨테이너 이미지 빌더
     * 도커 CLI 툴
       * 컨테이너 이미지 작성에 사용
       * 오픈 컨테이너 이니셔티브( OCI ) 표준을 준수
     * docerkfile
       * 컨테이너 이미지를 만드는 방법에 대해 일련의 지침을 지정
     * 이미지 레지스트리
       * 이미지 생성후 이미지의 업로드 및 관리를 위한 API



### 2-2. 컨테이너 오케스트레이션



* 쿠버네티스의 역할 : 

  * CPU, 메모리, 디스크와 같은 컴퓨팅 리소스 그룹을 가져와, 
  * 컨테이너를 배포하는 데 사용할 수 있도록  컨테이너 지향 API로 변환하는 것

  

* 쿠버네티스 API 작동 순서

  1. API를 사용하여 원하는 상태 설정

     > 예 : 컨테이너 이미지를 실행하기 위해 코어 3개, 메모리 10GB 필요

  2. 쿠버네티스 시스템이 일련의 리소스 검토

  3. 해당 컨테이너가 실행될 수 있는 위치 탐색

  4. 해당 위치에서 컨테이너가 실행되도록 스케줄링



* 오케스트레이터에서 문제 발생 시 컨테이너 복구

  * 컨테이너 내부 프로세스 충돌 시, 재실행
  * 정상 검사
    *  애플리케이션이 교착 상태에 있는지 확인

  * 로드밸런싱 조정 서비스
    * 레플리카 간 트래픽의 로드 밸런싱 방법을 정의하는 API
    * 로드밸런서에 이름이 부여
      * 여러 서비스를 클러스터 내에서 쉽게 연결 가능



### 2-3. 쿠버네티스 API

* 쿠버네티스 API
  * HTTP 및 JSON 기반의 RESTful API
  * API 서버를 제공
  * 쿠버네티스의 모든 구성 요소는 API를 이용하여 통신
  * 개발자와 운영자가 시스템 버전별로 작업 중인 것을 변경할 필요가 없도록 강력한 **하위 호환성** 제공



* 기본 오브젝트 : Pod, ReplicaSet, Service

  * Pod란?

    * 쿠버네티스 클러스 스케줄링에서 **가장 작은 원자( atomic ) 단위**

      > **원자 단위**?
      >
      > 파드의 모든 컨테이너가 클러스터에서 동일한 시스템을 차지하도록 보장한다는 의미

    * 하나 이상의 실행 중인 컨테이너로 구성

    * 컨테이너 사이에서 많은 자원을 공유

      * 예 : 

        * 동일한 네트워크 네임스페이스

        * 통신 네임스페이스 공유

          > IPC ( inter-process communication ) 















