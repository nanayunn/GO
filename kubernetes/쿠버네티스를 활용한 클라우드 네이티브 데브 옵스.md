# 쿠버네티스를 활용한 클라우드 네이티브 데브 옵스



* 클라우드의 핵심
  * 컴퓨터를 구매하는 대신 **컴퓨팅 리소스**를 구매하는 것



* 이로써 '시스템'은 개인이 개발한 프로그램이 아니라,
* 관련된 기술과 아키텍쳐가 밀접하게 상호 의존적인 프로그램이 되었다.



* 데브옵스란?
  * CAMS 
    * 문화, 자동화, 측정, 공유
  * 삼위일체
    * 사람과 문화
    * 과정과 실천
    * 도구와 기술
  * 코드형 인프라



* 컨테이너의 등장
  * 옴니버스 패키지



* 클라우드 함수와 펀테이너
  * 클라우드 함수
    * 클라우드 환경이 필요 없이 서버리스로 실행해주는 것
  * 펀테이너
    * 클라우드 함수와 컨테이너의 혼용



* 클라우드 네이티브란?

  * 오픈 소스 소프트웨어 기반의 클라우드, 컨테이너, 오케스트레이션한 애플리케이션과 서비스에 대한 용어

  * 자동화, 유비쿼터스와 유연성, 탄력성과 확장성, 역동성, 관측 가능성, 분산 







## 쿠버네티스 첫걸음



* 실습 도중 겪은 문제

  * kubectl port-forward deploy/demo 9999:8888 을 진행했을 때, 
  * socat을 찾을 수 없어 port-forwarding이 불가능 하다는 것
  * => kubernetes 노드가 설치되어있는 환경에 접속하여
  * sudo yum install socat을 진행하니 실행이 되었다. 
  * 원격 제어 환경에서도 socat 설치.

  





## 쿠버네티스 구축하기



1. 컨트롤 플레인
   * 클러스터의 두뇌 역할
   * 컨테이너 스케줄링, 서비스 관리, API 요청 처리
   * 구성요소
   * kube-apiserver
     * 컨트롤 플레인의 프론트 엔드 서버
     * API 요청 처리
   * etcd
     * 쿠버네티스와 관련된 모든 정보를 저장
   * kube-scheduler
     * 새로 생성된 pod를 실행할 노드 결정
   * kube-controller-manager
     * 리소스 컨트롤러 관리( deployment )
   * cloud-controller-manager
     * 클라우드 업체와 연동, 로드 밸런서나 디스크 볼륨과 같은 자원을 관리



2. 노드 컴포넌트
   * 사용자의 워크로드 실행
   * kubelet
     * 예약된 워크로드 실행을 위해 컨테이너 런타임 관리, 상태를 모니터링
   * kube-proxy
     * 서로 다른 노드에 있는 Pod간 통신 / Pod와 인터넷 사이의 네트워크 트래픽을 라우팅
   * 컨테이너 런타임
     * 컨테이너 시작, 중지
     * 컨테이너간 통신 처리
     * 일반적으로 도커 사용



* 자체 호스팅 쿠버네티스에서 고려해야하는 상황
  * 46 페이지 ~





## 쿠버네티스 오브젝트 다루기



* 디플로이먼트
  1. 관리와 스케줄링
     * 디플로이먼트 컨트롤러 => 디플리이먼트 리소스 => 레플리카 셋 => 레플리카
     * '항상 재시작'이 기본값인 경우, 레플리카 셋은 계속해서 재시작



* 파드와 레플리카 셋
  * 파드는 디플로이먼트 리소스에 의해 만들어진 레플리카 셋이 관리한다.



* 모든 동작은 *의도한 상태를 유지* 하기 위해 하는 동작
  * **조정 루프**
    * 의도한 상태와 실제 상태를 일치시키기 위한 조정 작업이 영원히 반복



* 쿠버네티스 스케줄러
  * 디플로이먼트가 Pod를 생성
  * 쿠버네티스는 요청된 Pod를 실행
  * **스케줄러**는 이 과정의 책임자!
    * 새로운 레플리카가 필요해서 디플로이먼트가 레플리카를 생성하면, 레플리카는 쿠버네티스 데이터 베이스에 생성되고, 스케줄러 수신함과 같은 대기열에 추가된다.
    * 스케줄러는 대기열을 탐색하여 할당되지 않은 Pod를 적절한 노드를 찾아 할당시킨다.
    * 이후, Pod가 노드에 스케줄링되면 노드의 kubelet이 실제 컨테이너를 실행한다.
    * 노드의 상태 변화를 감지하고 의도한 상태를 유지하는 작업은 kubelet이 한다. 





* 쿠버네티스는 기본적으로 **선언형** 시스템이다.
  * 쿠버네티스의 리소스( 디플로이먼트, 파드.. )는 모두 내부 데이터 베이스에 기록
  * 이러한 데이터 베이스 내의 기록사항을 바탕으로 동작한다.
  * `kubectl run`  명령어는 새로운 레코드( 디플로이먼트 )를 데이터 베이스에 등록하고 쿠버네티스가 이를 실행하는 것!
    * `kubectl run`보다는 YAML 매니페스트 형식의 파일에서 레코드를 수정, 적용하는 것이 좋다.



* 서비스 리소스
  * 서비스가 포트를 Pod의 포트로 포워딩
  * `selector`
    * 서비스에 라우팅할 Pod를 알려줌
    * Pod가 여러개일 경우, 무작위로 선택한 Pod로 요청 전달
      * 전통적인 로드 밸런서와 유사



* *중간 정리*
  * 디플로이먼트는 애플리케이션의 Pod Set 관리
  * 서비스는 Pod에 요청을 전달하는 단일 엔트리 포인트 제공





* 쿠버네티스 리소스 조회
  * `kubectl get <리소스 종류>`



* 쿠버네티스 리소스 설명
  * `kubectl describe <리소스 종류> <리소스 이름>`



* **helm** ( 헬름 - 쿠버네티스 패키지 매니저 )
  * helm CLI
    * 애플리케이션 설치 및 설정
  * helm chart
    * 애플리케이션을 실행하는 데 필요한 리소스, 의존성, 구성 가능한 변수를 지정 가능
    * 다만, 실제로 컨테이너 이미지 자체를 포함하지는 않고, 이미지를 찾을 수 있는 메타 데이터 항목만 포함
      * 쿠버네티스 YAML 매니페스트를 둘러싼 wrapper의 역할
  * 설치 실습 중 
    * `helm init --service-account tiller` 
    * 명령어는 helm 3 이후로 제거되어 더이상 유효하지 않다.
  * 리포지토리
    * 차트가 모여 공유할 수 있는 공간
  * 릴리스
    * 쿠버네티스 클러스터에서 실행되는 차트의 특정 인스턴스







## 리소스 관리하기



* 리소스 단위
  * 쿠버네티스 용어로 1 CPU는 일반적인 CPU 단위와 같음



* 리소스 요청
  * Pod의 스펙에 지정된 리소스보다 적은 리소스를 가진 노드에는 Pod가 스케줄링되지 않는다.



* 리소스 상한
  * Pod가 사용할 수 있는 최대 리소스 양을 지정
  * 상한을 초과하는 Pod는 종료되고, 다시 스케줄링된다.
    * => Pod가 클러스터 용량을 과다하게 점유하는 것을 막을 수 있음
  * 쿠버네티스는 **오버커밋**을 허용!
    * 오버커밋이란?
    * 노드 내 컨테이너의 모든 리소스 상한의 합계가 해당 노드의 전체 리소스를 초과할 수 있음을 의미
    * => ''설마.. 상한은 넘지 않겠지'' 라는 식으로 허용하는 것....
    * 상한을 넘기면 보통은 리소스 요청을 가장 많이 초과한 Pod부터 종료된다.
      * 리소스를 과다하게 초과해서 급한 경우에는, 상한을 넘기지 않았어도 종료될 수 있다.



* **컨테이너**
  * 컨테이너는 크기가 작을수록 좋다!
    * 더 빨리 빌드되고, 
    * 이미지 저장공간도 덜 차지하고
    * 풀링도 빠르고
    * 보안 취약점이 줄어드니까!
  * 컨테이너 생명주기
    * 컨테이너 stuck 상태 체크
      * 프로세스는 실행 중인데 요청을 처리 못하는 상태..
    * 











































