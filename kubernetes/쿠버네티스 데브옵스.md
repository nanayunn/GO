[TOC]



## 1. 소프트웨어 세상의 세 가지 혁명



1. 클라우드 혁명
2. 데브옵스의 탄생
3. 컨테이너



* => 3가지 혁명의 결과로, *클라우드 네이티브* 소프트웨어 환경이 만들어짐



### 1. 클라우드 혁명

* "클라우드"

  1. 물리적인 컴퓨터 자원을 구매하는 것 대신, *컴퓨팅 리소스*를 구매하는 방식

  *  => 원격 컴퓨팅 파워가 중요해진 시대

  2. 구축과 업그레이드가 필요하지 않은 IaaS( Infra as a Service )

  * 클라우드 인프라의 상품화
  * => 개발과 운영의 통합성을 불러옴



### 2. 데브옵스

> 소프트웨어의 개발(Development)과 운영(Operations)의 합성어
>
> * 소프트웨어 개발자와 운영조직 간의 소통, 협업 및 통합을 강조하는 개발 환경이나 문화 ( 상호 의존적 대응 )
> * 소프트웨어 제품과 서비스를 빠른 시간에 개발 및 배포하는 것을 목적으로 한다.



* 과거
  * 개발자는 소프트웨어 작성
  * 운영자는 상용환경에서 소프트웨어를 실행 및 관리
  * => 중복되는 업무가 거의 없었다!
  * '시스템' = 개인이 개발한 소프트웨어



* 클라우드 혁명 이후..?
  * 복잡한 분산 시스템
  * 상호의존적인 클라우드 시스템
  * '시스템' = 밀접하게 연결되고, 상호의존적인 다양한 소프트웨어..
    * 예 : 사내 소프트웨어, 클라우드 서비스, 네트워크 리소스, 로드 밸런서, 모니터링...



* 데브옵스에 대한 정의는 제각각
  * 중요한 포인트는, 데브옵스는 기술적인 문제 보다는 주로 조직적인 문화와 더 관련이 깊다는 것이다.



* 비즈니스 이점
  * 데브옵스의 장점?
    * 클라우드 자동화와 실행으로 릴리스 주기를 단축
    * => 소프트 웨어의 품질 향상 + 소프트웨어가 상용 환경에서 상시 운영!
  * 데브옵스의 핵심 목표
    * 속도, 민첩성, 협업, 자동화, 소프트웨어 품질



* 코드형 인프라

  * IAC ( Infastructure As Code )
    * 클라우드 환경에서 하드웨어는 '클라우드'에 존재
    * => 어떤 의미로 본다면, 모든 것이 소프트웨어
    * => 소프트웨어 형식으로 인프라를 자동 공급

  

* 정리
  * 클라우드 + 협업의 필요성 + 인프라의 소프트웨어화
  * => 소프트웨어의 운영 문제 
    * 소프트웨어를 배포하는 방법 중 이식성이 높은 방법은 무엇이 있을까?



### 3. 컨테이너 등장

* 소프트웨어를 배포하려면?
  * 소프트웨어 + 의존성( 소프트웨어와 관련된 모든 것 ) + 구성( 소프트웨어를 사용 가능한 서비스로 만들어주는 것 )
    * 의존성 : 라이브러리, 인터프리터, 컴파일러,,
    * 구성 : 설정, 라이선스 키, 데이터베이스 패스워드



* 배포 과정의 변화

  1. 코드 구성 관리 시스템

  * 퍼핏, 앤서블 ...
  * 소프트웨어를 설치, 실행, 구성, 업데이트
    * 단점 : 언어에 종속되며, 의존성 문제 완전히 해결 불가

  2. 옴니버스 패키지

  * 애플리케이션에 필요한 모든 것을 *단일 파일*로 구성
    * 소프트웨어, 구성, 소프트웨어 컴포넌트, 컴포넌트의 구성, 컴포넌트의 의존성..

  3. 가상 머신 이미지

  * 애플리케이션 실행을 위해 필요한 전체 컴퓨터 시스템
    * 느린 다운로드와 배포, 비효율적인 성능과 리소스

  4. 컨테이너

  * 애플리케이션의 실행에 필요한 것은 모두 *이미지파일*에 저장
    * 레이어 방식의 파일 구성
  * 가상화의 오버헤드 없이, 실제 CPU에서 실행





* 컨테이너의 특징
  * **플러그 앤 플레이 애플리케이션**
  * 배포 및 패키징, 
  * 생성된 컨테이너 이미지는 재사용이 가능
    * 이것을 이용하여 스케일링, 리소스 할당이 가능
  * 컨테이너의 의존성은 운영체제 커널뿐..



* 컨테이너 오케스트레이션
  * 오케스트레이터
    * 다양한 머신을 하나의 클러스터로 결합하도록 설계된 소프트웨어의 한 종류
      * 클러스터 => 사용자의 입장에서, 컨테이너를 실행할 수 있는 일종의 컴퓨터
    * 일반적으로 스케줄링, 오케스트레이션, 클러스터 관리를 담당
    * 오케스트레이션 != 스케줄링
      * 오케스트레이션 :
        * 서비스의 공통적인 목표를 위해 서로 다른 역할을 조정하고 나열
      * 스케줄링 : 
        * 사용 가능한 리소스를 관리하고 가장 효율적으로 실행할 수 있는 워크로드를 할당하는 것을 의미
          * 지정된 시간에 예약된 작업을 실행하는 스케줄링 의미와 혼동하면 **안된다**





* 쿠버네티스
  * 구글이 개발한 컨테이너 오케스트레이터
  * '보그'에서 시작하여 '쿠버네티스' 오픈 소스 프로젝트로 발전
  * 쿠버네티스가 특별한 이유?
    * 시스템 관리자의 역할
      * 자동화, 장애 조치, 모니터링..
      * => 전통적인 시스템 관리 작업을 대신해주어서, 팀이 보다 핵심적인 작업에 집중할 수 있도록 도움
    * 다양한 기능과 API, 확장하는 생태계
    * 간편한 배포 작업
      * 롤링 업데이트로 무중단 배포
      * 오토 스케일링 지원
        * 클라우드 서비스 업체와 관계없이 사용 가능
        * 서비스 업체가 제공하는 기능에 리소스를 적절하게 매핑
          * 각 클라우드 업체의 세부 사항을 추상화하여 각각에 맞는 기능을 제공
          * => 소프트웨어 **실행 방식**에 대한 이식 가능성
  * 다만, 만능은 아니다 : 
    * 부적합한 애플리케이션 존재
      * 예 :  데이터 베이스
      * 데이터 베이스 레플리카는 서로 호환되지 않는다..
    * 서버리스 플랫폼에서 실행할 수 있는 애플리케이션들..





* 클라우드 함수와 펀테이너
  * 클라우드 함수 : 
    * FaaS( Function as a Service )
    * 클라우드 위에 함수를 등록하고 트리거를 걸어 사용
      * 즉, 이벤트가 발생하면 등록해놓은 함수가 동작
      * 함수 내용 작성을 제외한 모든 것을 클라우스 서비스 업체가 처리!
  * 펀테이너
    * 클라우드 함수와 컨테이너의 혼용
    * 예 : 쿠버네티스 클러스터에서 클라우드 함수를 실행하는 것
  * Knative
    * 컨테이너와 클라우드 함수를 모두 포함하는 쿠버네티스 기반 소프트웨어 제공 플랫폼



* 클라우드 네이티브

  * 클라우드 환경 전체에 지속적인 개발과 자동화된 관리 환경을 제공하기 위해 특별히 설계된 애플리케이션

  * 클라우드 네이티브 환경의 특징

    * 자동화

      * 일반적인 표준, 형식, 인터페이스를 다라 자동으로 애플리케이션을 배포

    * 유비쿼터스와 유연성

      * 컨테이너화된 마이크로서비스는 디스크와 같은 물리적 자원이나, 실행되는 컴퓨팅 노드에 대한 특정 지식과 분리!
      * => 클러스터 간의, 노드 간의 이동을 자유롭게 할 수 있다.

    * 탄력성과 확장성

      * 분산된 환경을 기반으로 고가용성을 보장

    * 역동성

      * 사용 가능한 리소스를 최대한 활용, 컨테이너 스케줄링

    * 관측가능성

      * 분산 시스템의 핵심 요구사항
      * 모니터링, 로깅 등으로 시스템의 작동 상태와 장애 상태를 이해하는 데 도움을 줌

    * 분산

      * 분산 마이크로 서비스
      * 합치면 애플리케이션

      



* 운영의 미래
  * 데브옵스로 인해 구분되지 않는 개발과 운영 업무
  * DPE( developer productivity engineering )
    * 운영 팀을 대신
    * 개발자가 더 나은 환경에서 개발 업무를 할 수 있도록 도움을 제공
    * 





